{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Teckel provides a common interface for wrapping your ruby business logic into, with enforced input, output and error data structures.</p> <p>The two main components are Operations and Chains.</p>"},{"location":"#motivation","title":"Motivation","text":"<p>Working with Interactor, Trailblazer's Operation and Dry-rb's Transaction and probably a hand full of inconsistent \"service objects\", I missed a system that:</p> <ol> <li>provides and enforces well defined input, output and error structures</li> <li>makes chaining multiple operation easy and reliable</li> <li>is easy to debug</li> </ol>"},{"location":"#about-code-samples","title":"About Code Samples","text":"<p>Code samples are tested using byexamples.</p> <p>They all use a common base setup to have some fake objects to work with:</p> <pre><code># frozen_string_literal: true\n\nrequire \"English\"\nrequire \"dry-types\"\nrequire \"dry-struct\"\n\nWarning[:experimental] = false if Warning.respond_to? :[]\n\nmodule Types\n  include Dry.Types()\nend\n\nmodule FakeDB\n  Rollback = Class.new(RuntimeError)\n\n  def self.transaction\n    yield\n  rescue Rollback # standard:disable Lint/UselessRescue\n    # doing rollback ...\n    raise\n  end\nend\n\nclass User\n  def initialize(name:, age:)\n    @name, @age = name, age\n  end\n  attr_reader :name, :age\n\n  def save\n    !underage?\n  end\n\n  def errors\n    underage? ? [{age: \"underage\"}] : nil\n  end\n\n  def underage?\n    @age &lt;= 18\n  end\nend\n</code></pre>"},{"location":"chains/around/","title":"Around hook","text":"<p>Chains might use a around hook eg. for wrapping the entire execution in a database transaction. Their hooks gets total control over the execution, so it needs to take care of calling the chain and returning it's result.</p> <pre><code>require \"teckel/chain\"\n\nclass CreateUser\n  include ::Teckel::Operation\n\n  result!\n  input  Types::Hash.schema(name: Types::String, age: Types::Coercible::Integer.optional)\n  output Types.Instance(User)\n  error  Types::Hash.schema(message: Types::String, errors: Types::Array.of(Types::Hash))\n\n  def call(input)\n    user = User.new(name: input[:name], age: input[:age])\n    if user.save\n      success!(user)\n    else\n      fail!(message: \"Could not safe User\", errors: user.errors)\n    end\n  end\nend\n\nclass AddFriend\n  include ::Teckel::Operation\n\n  result!\n  settings Struct.new(:fail_befriend)\n  input  Types.Instance(User)\n  output Types::Hash.schema(user: Types.Instance(User), friend: Types.Instance(User))\n  error  Types::Hash.schema(message: Types::String)\n\n  def call(user)\n    if settings&amp;.fail_befriend == :fail\n      fail!(message: \"Did not find a friend.\")\n    else\n      success!(user: user, friend: User.new(name: \"A friend\", age: 42))\n    end\n  end\nend\n\nLOG = []\n\nclass MyChain\n  include Teckel::Chain\n\n  around -&gt;(chain, input) {\n    result = nil\n    begin\n      LOG &lt;&lt; :before\n      FakeDB.transaction do\n        # The hook needs to call the chain:    \n        result = chain.call(input)\n\n        raise FakeDB::Rollback if result.failure?\n      end\n      LOG &lt;&lt; :after\n\n      result # ... and return the success result\n    rescue FakeDB::Rollback\n      LOG &lt;&lt; :rollback\n\n      result # ... and return the failure result\n    end\n  }\n\n  step :create, CreateUser\n  step :befriend, AddFriend\nend\n\nfailure_result = MyChain.with(befriend: :fail).call(name: \"Bob\", age: 23)\nfailure_result\n#=&gt; #&lt;Teckel::Chain::Result:&lt;...&gt;&gt;\n\n# triggered DB rollback\nLOG\n#=&gt; [:before, :rollback]\n\n# additional step information\nfailure_result.step\n#=&gt; :befriend\n\n# behaves just like a normal +Result+\nfailure_result.failure?\n#=&gt; true\n\nfailure_result.failure\n#=&gt; {message: \"Did not find a friend.\"}\n</code></pre>"},{"location":"chains/basics/","title":"Chain basics","text":"<p>Chains run multiple Operations (\"steps\") in order, returning the success value of the last step. When any step returns a failure, the chain is stopped and that failure is returned.</p> <p>Operations used as steps need to return result objects (implementing <code>Teckel::Result</code>).</p> <p>Chains always return a result object including the name of the step they origin from. This is especially useful to switch error handling for failure results.</p>"},{"location":"chains/basics/#example","title":"Example","text":"<p>Defining a simple Chain with three steps.</p> <pre><code>require \"teckel/chain\"\n\nclass CreateUser\n  include ::Teckel::Operation\n\n  result!\n\n  input  Types::Hash.schema(name: Types::String, age: Types::Coercible::Integer.optional)\n  output Types.Instance(User)\n  error  Types::Hash.schema(message: Types::String, errors: Types::Array.of(Types::Hash))\n\n  def call(input)\n    user = User.new(name: input[:name], age: input[:age])\n    if user.save\n      success!(user)\n    else\n      fail!(message: \"Could not save User\", errors: user.errors)\n    end\n  end\nend\n\nclass LogUser\n  include ::Teckel::Operation\n\n  result!\n\n  input Types.Instance(User)\n  error none\n  output input\n\n  def call(usr)\n    Logger.new(File::NULL).info(\"User #{usr.name} created\")\n    success!(usr) # we need to return the correct output type\n  end\nend\n\nclass AddFriend\n  include ::Teckel::Operation\n\n  result!\n\n  settings Struct.new(:fail_befriend)\n\n  input Types.Instance(User)\n  output Types::Hash.schema(user: Types.Instance(User), friend: Types.Instance(User))\n  error  Types::Hash.schema(message: Types::String)\n\n  def call(user)\n    if settings&amp;.fail_befriend == :fail\n      fail!(message: \"Did not find a friend.\")\n    else\n      success!(user: user, friend: User.new(name: \"A friend\", age: 42))\n    end\n  end\nend\n\nclass MyChain\n  include Teckel::Chain\n\n  step :create, CreateUser\n  step :log, LogUser\n  step :befriend, AddFriend\n\n  finalize!\nend\n\nresult = MyChain.call(name: \"Bob\", age: 23)\n#=&gt; #&lt;Teckel::Chain::Result:&lt;...&gt;&gt;\n\nresult.success[:user]\n#=&gt; #&lt;User:&lt;...&gt; @age=23, @name=\"Bob\"&gt;\n\nresult.success[:friend]\n#=&gt; #&lt;User:&lt;...&gt; @age=42, @name=\"A friend\"&gt;\n\nfailure_result = MyChain.with(befriend: :fail).call(name: \"Bob\", age: 23)\nfailure_result\n#=&gt; #&lt;Teckel::Chain::Result:&lt;...&gt;&gt;\n\n# additional step information\nfailure_result.step                   \n#=&gt; :befriend\n\n# behaves just like a normal +Result+\nfailure_result.failure?\n#=&gt; true\n\nfailure_result.failure\n#=&gt; {message: \"Did not find a friend.\"}\n</code></pre>"},{"location":"chains/basics/#pattern-matching","title":"Pattern matching","text":"<p>Hash style:</p> <pre><code>result = case MyChain.call(name: \"Bob\", age: 23)\nin { success: false, step: :befriend, value: value }\n  [\"Failed\", value]\nin { success: true, value: value }\n  [\"Success result\", value]\nend\n\nresult\n#=&gt; [\"Success result\",\n  {friend: #&lt;User:&lt;...&gt; @age=42, @name=\"A friend\"&gt;,\n   user: #&lt;User:&lt;...&gt; @age=23, @name=\"Bob\"&gt;}]\n</code></pre> <p>Array style:</p> <pre><code>result = case MyChain.with(befriend: :fail).call(name: \"Bob\", age: 23)\nin [false, :befriend, value]\n  [\"Failed\", value]\nin [true, value]\n  [\"Success result\", value]\nend\n\nresult\n#=&gt; [\"Failed\", {message: \"Did not find a friend.\"}]\n</code></pre>"},{"location":"operations/basics/","title":"Operation basics","text":""},{"location":"operations/basics/#using-in-line-constants-as-contracts","title":"Using in-line constants as contracts","text":"<pre><code>class CreateUserInline\n  include Teckel::Operation\n\n  class Input\n    def initialize(name:, age:)\n      @name, @age = name, age\n    end\n    attr_reader :name, :age\n  end\n\n  input_constructor -&gt;(data) { Input.new(**data) }\n\n  Output = ::User\n\n  class Error\n    def initialize(message, errors)\n      @message, @errors = message, errors\n    end\n    attr_reader :message, :errors\n  end\n\n  error_constructor :new\n\n  def call(input)\n    user = ::User.new(name: input.name, age: input.age)\n    if user.save\n      success!(user)\n    else\n      fail!(\"Could not save User\", user.errors)\n    end\n  end\nend\n</code></pre> <p>A Successful call:</p> <pre><code>CreateUserInline.call(name: \"Bob\", age: 23)\n#=&gt; #&lt;User:&lt;...&gt; @age=23, @name=\"Bob\"&gt;\n</code></pre> <p>A failure call:</p> <pre><code>CreateUserInline.call(name: \"Bob\", age: 10)\n#=&gt; #&lt;CreateUserInline::Error:&lt;...&gt;\n   @errors=[{age: \"underage\"}],\n   @message=\"Could not save User\"&gt;\n</code></pre> <p>Calling with unsuspected input:</p> <pre><code>CreateUserInline.call(unwanted: \"input\") rescue $ERROR_INFO\n#=&gt; #&lt;ArgumentError: missing keywords: :name, :age&gt;\n\nCreateUserInline.call(unwanted: \"input\", name: \"a\", age: 10) rescue $ERROR_INFO\n#=&gt; #&lt;ArgumentError: unknown keyword: :unwanted&gt;\n</code></pre>"},{"location":"operations/basics/#using-drytypes-as-contracts","title":"Using Dry::Types as contracts","text":"<p>Here is a simple Operation using Dry::Types for it's input, output and error contracts:</p> <pre><code>class CreateUserDry\n  include Teckel::Operation\n\n  input  Types::Hash.schema(name: Types::String, age: Types::Coercible::Integer)\n  output Types.Instance(User)\n  error  Types::Hash.schema(message: Types::String, errors: Types::Array.of(Types::Hash))\n\n  def call(input)\n    user = User.new(name: input[:name], age: input[:age])\n    if user.save\n      success!(user)\n    else\n      fail!(message: \"Could not save User\", errors: user.errors)\n    end\n  end\nend\n</code></pre> <p>A Successful call:</p> <pre><code>CreateUserDry.call(name: \"Bob\", age: 23)\n#=&gt; #&lt;User:&lt;...&gt; @age=23, @name=\"Bob\"&gt;\n</code></pre> <p>A failure call:</p> <pre><code>CreateUserDry.call(name: \"Bob\", age: 10)\n#=&gt; {errors: [{age: \"underage\"}], message: \"Could not save User\"}\n</code></pre> <p>Build your contracts in a way that let you know:</p> <pre><code>CreateUserDry.call(unwanted: \"input\") rescue $ERROR_INFO\n#=&gt; #&lt;Dry::Types::MissingKeyError: :name is missing in Hash input&gt;\n</code></pre> <p>If your contracts support Feed an instance of the input class directly to call:</p> <pre><code>CreateUserDry.call(CreateUserDry.input[name: \"Bob\", age: 23])\n#=&gt; #&lt;User:&lt;...&gt; @age=23, @name=\"Bob\"&gt;\n</code></pre>"},{"location":"operations/basics/#expecting-none","title":"Expecting <code>none</code>","text":"<pre><code>class NoOp\n  include Teckel::Operation\n\n  input none\n  output none\n  error none\n\n  # injecting values to fake behavior\n  settings Struct.new(:out, :err, :ret, keyword_init: true)\n\n  def call(_input) # you'll still need to take that argument\n    if settings\n      fail!(nil)             if settings.err == :nil\n      success!(nil)          if settings.out == :nil\n      fail!                  if settings.err == :nothing\n      success!               if settings.out == :nothing\n      fail!(settings.err)    if settings.err\n      success!(settings.out) if settings.out\n\n      settings.ret # any normal return value will be ignored\n    end\n  end\nend\n</code></pre> <p>Expects to be called with nothing or <code>nil</code>, calling with any value will raise an error:</p> <pre><code>NoOp.call\n#=&gt; nil\n\nNoOp.call(nil)\n#=&gt; nil\n\nNoOp.call(\"test\") rescue $ERROR_INFO\n#=&gt; #&lt;ArgumentError: None called with arguments&gt;\n</code></pre> <p>Expects no success value:</p> <pre><code>NoOp.call\n#=&gt; nil\n\nNoOp.with(out: nil).call\n#=&gt; nil\n\nNoOp.with(out: :nil).call\n#=&gt; nil\n\nNoOp.with(out: :nothing).call\n#=&gt; nil\n\nNoOp.with(out: \"test\").call rescue $ERROR_INFO\n#=&gt; #&lt;ArgumentError: None called with arguments&gt;\n\nNoOp.with(ret: \"test\").call # return values will be ignored\n#=&gt; nil\n</code></pre> <p>Expects no failure value:</p> <pre><code>NoOp.with(err: nil).call\n#=&gt; nil\n\nNoOp.with(err: :nil).call\n#=&gt; nil\n\nNoOp.with(err: :nothing).call\n#=&gt; nil\n\nNoOp.with(err: \"test\").call rescue $ERROR_INFO\n#=&gt; #&lt;ArgumentError: None called with arguments&gt;\n</code></pre>"},{"location":"operations/basics/#pattern-matching","title":"Pattern matching","text":"<pre><code>class CreateUser\n  include ::Teckel::Operation\n\n  result!\n\n  input  Types::Hash.schema(name: Types::String, age: Types::Coercible::Integer.optional)\n  output Types.Instance(User)\n  error  Types::Hash.schema(message: Types::String, errors: Types::Array.of(Types::Hash))\n\n  def call(input)\n    user = User.new(name: input[:name], age: input[:age])\n    if user.save\n      success!(user)\n    else\n      fail!(message: \"Could not save User\", errors: user.errors)\n    end\n  end\nend\n</code></pre> <p>Hash style:</p> <pre><code>result = case CreateUser.call(name: \"Bob\", age: 23)\nin { success: false, value: value }\n  [\"Failed\", value]\nin { success: true, value: value }\n  [\"Success result\", value]\nend\n\nresult\n#=&gt; [\"Success result\", #&lt;User:&lt;...&gt; @age=23, @name=\"Bob\"&gt;]\n</code></pre> <p>Array style:</p> <pre><code>result = case CreateUser.call(name: \"Bob\", age: 10)\nin [false, value]\n  [\"Failed\", value]\nin [true, value]\n  [\"Success result\", value]\nend\n\nresult\n#=&gt; [\"Failed\", {errors: [{age: \"underage\"}], message: \"Could not save User\"}]\n</code></pre>"},{"location":"operations/dependency_injection/","title":"Inject settings","text":"<p>Your <code>call</code> method should only get data to work on. Use settings for \"how\" or \"with what\" to do it.</p> <p>Settings (just as input, output and error) are defined using a contract class and made available via the <code>#settings</code> instance method only when set.</p> <pre><code>class MyOperation\n  include ::Teckel::Operation\n\n  settings Struct.new(:logger)\n\n  input none\n  output none\n  error none\n\n  def call(_input)\n    puts \"no settings\" if settings.nil?\n    settings.logger.puts \"called\" if settings&amp;.logger\n  end\nend\n</code></pre> <p>With no settings:</p> <pre><code>MyOperation.call(nil)\nno settings\n#=&gt; nil\n</code></pre> <p>With Logger</p> <pre><code>require 'stringio'\n\nmy_logger = StringIO.new\nMyOperation.with(my_logger).call()\nmy_logger.string\n#=&gt; \"called\\n\"\n</code></pre>"},{"location":"operations/dependency_injection/#as-constant","title":"As constant","text":"<pre><code>class OtherOperation\n  include Teckel::Operation\n  class Settings\n    def initialize(foo:, bar:)\n      @foo, @bar = foo, bar\n    end\n    attr_reader :foo, :bar\n  end\n  # MyOperation.with(\"foo\", \"bar\") # -&gt; Settings.new(\"foo\", \"bar\")\n  settings_constructor :new\nend\n</code></pre>"},{"location":"operations/dependency_injection/#default-settings","title":"Default Settings","text":"<p>Initialize Setting by default. This avoids <code>nil</code> settings, but forces you to either make your <code>Settings</code> class accept no arguments for initialization, or provide acceptable defaults.</p> <p>Note that, default settings will not get merged with call time setting. Default settings will be ignored when calling like this: <code>MyOperation.with(call_time_settings).call</code>.</p> <pre><code>class BaseOperation\n  include Teckel::Operation\n\n  class Settings\n    def initialize(*values)\n      @values = values\n    end\n    attr_reader :values\n  end\n\n  settings_constructor :new\n\n  input  none\n  output Types::Array\n  error  none\n\n  def call(_)\n    success!(settings.values)\n  end\nend\n</code></pre>"},{"location":"operations/dependency_injection/#empty-defaults","title":"Empty defaults","text":"<pre><code>class EmptyDefaults &lt; BaseOperation\n  default_settings! # Settings.new\nend\n</code></pre> <p>With no settings:</p> <pre><code>EmptyDefaults.call\n#=&gt; []\n</code></pre> <p>With injected settings:</p> <pre><code>EmptyDefaults.with(:injected).call\n#=&gt; [:injected]\n</code></pre>"},{"location":"operations/dependency_injection/#static-defaults","title":"Static defaults","text":"<pre><code>class StaticDefaults &lt; BaseOperation\n  default_settings!(:foo, :bar) # Settings.new(:foo, :bar)\nend\n</code></pre> <p>With no settings:</p> <pre><code>StaticDefaults.call\n#=&gt; [:foo, :bar]\n</code></pre> <p>With injected settings:</p> <pre><code>StaticDefaults.with(:injected).call\n#=&gt; [:injected]\n</code></pre>"},{"location":"operations/dependency_injection/#call-time-defaults","title":"Call time defaults","text":"<pre><code>class CallTimeDefaults &lt; BaseOperation\n  default_settings! -&gt; { settings_constructor.call(Time.now) } # Settings.new(Time.now)\nend\n</code></pre> <p>With no settings:</p> <pre><code>a = CallTimeDefaults.call.first\nb = CallTimeDefaults.call.first\na.class\n#=&gt; Time\nb.class\n#=&gt; Time\na &lt; b\n#=&gt; true\n</code></pre> <p>With injected settings:</p> <pre><code>CallTimeDefaults.with(:injected).call\n#=&gt; [:injected]\n</code></pre>"},{"location":"operations/input_data_validation/","title":"Input Data Validation","text":"<p>Usually, input definitions are quite simple and raise an error if the provided data does not match.  How to return a meaningful error result when input data does not conform to specifications.</p> <p>This example uses dry-validation, but you are free on how to validate your input data.</p> <pre><code>require \"dry/validation\"\n\nclass User\n  def initialize(name:, age:)\n    @name, @age = name, age\n  end\n  attr_reader :name, :age\n\n  class &lt;&lt; self\n    attr_accessor :has_db\n  end\n\n  def save\n    !!User.has_db\n  end\n\n  def errors\n    User.has_db ? nil : { database: [\"not connected\"] }\n  end\nend\n\nDry::Validation.load_extensions(:predicates_as_macros)\nclass CreateUserContract &lt; Dry::Validation::Contract\n  import_predicates_as_macros\n\n  schema do\n    required(:name).filled(:string)\n    required(:age).value(:integer)\n  end\n\n  rule(:age).validate(gteq?: 18)\nend\n\nclass CreateUser\n  include Teckel::Operation\n  result!\n\n  input CreateUserContract.new\n\n  input_constructor(-&gt;(input){\n    result = self.class.input.call(input)\n    if result.success?\n      result.to_h\n    else\n      fail!(message: \"Input data validation failed\", errors: result.errors.to_h)\n    end\n  })\n\n  output Types.Instance(User)\n  error  Types::Hash.schema(\n    message: Types::String,\n    errors: Types::Hash.map(Types::Symbol, Types::Array.of(Types::String))\n  )\n\n  def call(input)\n    user = User.new(**input)\n\n    if user.save\n      success! user\n    else\n      fail!(message: \"Could not save User\", errors: user.errors)\n    end\n  end\n\n  finalize!\nend\n</code></pre> <pre><code>User.has_db = true\nCreateUser.call(name: \"Bob\", age: 23).success\n#=&gt; #&lt;User:&lt;...&gt; @age=23, @name=\"Bob\"&gt;\n</code></pre> <p>Error from response from our validation in <code>input_constructor</code>:</p> <pre><code>CreateUser.call(name: \"Bob\", age: 10).failure\n#=&gt; {errors: {age: [\"must be greater than or equal to 18\"]},\n    message: \"Input data validation failed\"}\n</code></pre> <p>Error response from the our operation <code>call</code>:</p> <pre><code>User.has_db = false\nCreateUser.call(name: \"Bob\", age: 23).failure\n#=&gt; {errors: {database: [\"not connected\"]}, message: \"Could not save User\"}\n</code></pre> <p>Errors raised in <code>input_constructor</code> need to conform to the defined <code>error</code>:</p> <pre><code>&gt;&gt; class IncorrectFailure\n..   include Teckel::Operation\n.. \n..   result!\n.. \n..   input(-&gt;(input) { input }) # pass\n..   input_constructor(-&gt;(_input) {\n..     fail!(\"Input data validation failed\")\n..   })\n.. \n..   output none\n..   error  Types::Hash.schema(message: Types::String)\n.. \n..   def call(_); end\n..\n..   finalize!\n.. end\n\n&gt;&gt; IncorrectFailure.call rescue $ERROR_INFO\n=&gt; #&lt;Dry::Types::ConstraintError:&lt;...&gt; \"Input data validation failed\" violates constraints (type?(Hash, \"Input data validation failed\") failed)&gt;\n</code></pre>"},{"location":"operations/result_objects/","title":"Result objects","text":""},{"location":"operations/result_objects/#build-in","title":"Build-in","text":"<pre><code>class CreateUser\n  include Teckel::Operation\n\n  # Shortcut for\n  # result Teckel::Operation::Result\n  result!\n\n  input  Types::Hash.schema(name: Types::String, age: Types::Coercible::Integer)\n  output Types.Instance(User)\n  error  Types::Hash.schema(message: Types::String, errors: Types::Array.of(Types::Hash))\n\n  def call(input)\n    user = User.new(name: input[:name], age: input[:age])\n    if user.save\n      success!(user)\n    else\n      fail!(message: \"Could not save User\", errors: user.errors)\n    end\n  end\nend\n</code></pre> <p>A success call:</p> <pre><code>result = CreateUser.call(name: \"Bob\", age: 23)\nresult\n#=&gt; #&lt;Teckel::Operation::Result:&lt;...&gt;&gt;\n\nresult.successful?\n#=&gt; true\n\nresult.failure?\n#=&gt; false\n\nresult.success\n#=&gt; #&lt;User:&lt;...&gt; @age=23, @name=\"Bob\"&gt;\n</code></pre> <p>A failure call:</p> <pre><code>result = CreateUser.call(name: \"Bob\", age: 10)\nresult\n#=&gt; #&lt;Teckel::Operation::Result:&lt;...&gt;&gt;\n\nresult.successful?\n#=&gt; false\n\nresult.failure?\n#=&gt; true\n\nresult.failure\n#=&gt; {errors: [{age: \"underage\"}], message: \"Could not save User\"}\n\nresult.success do |value|\n  # do something with the error value\n  puts value[:message]\n  # return something useful\n  value[:errors]\nend\n  Could not save User\n#=&gt; [{age: \"underage\"}]\n</code></pre>"},{"location":"operations/result_objects/#custom","title":"Custom","text":"<p>You can use your own result object. If you plan using your operation in a <code>Chain</code>, the should implement the interface defined in <code>Teckel::Result</code>.</p> <pre><code>require 'time'\n\nclass MyResult\n  include Teckel::Result\n  def initialize(value, success, opts = {})\n    @value, @success, @opts = value, (!!success).freeze, opts\n  end\n\n  # implementing Teckel::Result\n  attr_reader :value\n\n  # implementing Teckel::Result\n  def successful?\n    @success\n  end\n\n  def at\n    @opts[:at]\n  end\nend\n\nclass CreateUserOtherResult\n  include Teckel::Operation\n\n  result MyResult\n  result_constructor -&gt;(value, success) { MyResult.new(value, success, at: Time.now) }\n\n  input  Types::Hash.schema(name: Types::String, age: Types::Coercible::Integer)\n  output Types.Instance(User)\n  error  Types::Hash.schema(message: Types::String, errors: Types::Array.of(Types::Hash))\n\n  def call(input)\n    user = User.new(name: input[:name], age: input[:age])\n    if user.save\n      success!(user)\n    else\n      fail!(message: \"Could not save User\", errors: user.errors)\n    end\n  end\n  finalize!\nend\n\nresult = CreateUserOtherResult.call(name: \"Bob\", age: 23)\nresult\n#=&gt; #&lt;MyResult:&lt;...&gt;\n  @opts={at: &lt;time&gt;}, \n  @success=true,\n  @value=#&lt;User:&lt;...&gt;&gt;\n\nresult.at\n#=&gt; &lt;time&gt;\n\nresult.successful?\n#=&gt; true\n\nresult.failure?\n#=&gt; false\n\nresult.value\n#=&gt; #&lt;User:&lt;...&gt; @age=23, @name=\"Bob\"&gt;\n</code></pre>"},{"location":"operations/result_objects/#dry-monads","title":"Dry-Monads","text":"<pre><code>require 'dry/monads'\n\n# we need some glue code to make them work with Chains\nclass DryResult\n  include Teckel::Result\n  include Dry::Monads[:result]\n\n  def initialize(value, success)\n    @value, @success = value, (!!success).freeze\n  end\n\n  # implementing Teckel::Result\n  attr_reader :value\n\n  # implementing Teckel::Result\n  def successful?\n    @success\n  end\n\n  def to_monad\n    @success ? Success(value) : Failure(value)\n  end\nend\n\nclass CreateUserDry\n  include Teckel::Operation\n\n  result DryResult\n  result_constructor :new\n\n  input  Types::Hash.schema(name: Types::String, age: Types::Coercible::Integer)\n  output Types.Instance(User)\n  error  Types::Hash.schema(message: Types::String, errors: Types::Array.of(Types::Hash))\n\n  def call(input)\n    user = User.new(name: input[:name], age: input[:age])\n    if user.save\n      success!(user)\n    else\n      fail!(message: \"Could not save User\", errors: user.errors)\n    end\n  end\n  finalize!\nend\n\nresult = CreateUserDry.call(name: \"Bob\", age: 23)\nresult.to_monad\n#=&gt; Success(#&lt;User:&lt;...&gt; @age=23, @name=\"Bob\"&gt;)\n</code></pre>"}]}
{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Teckel provides a common interface for wrapping your ruby business logic into, with enforced input, output and error data structures. The two main components are Operations and Chains . Motivation Working with Interactor , Trailblazer's Operation and Dry-rb's Transaction and probably a hand full of inconsistent \"service objects\", I missed a system that: provides and enforces well defined input, output and error structures makes chaining multiple operation easy and reliable is easy to debug About Code Samples Code samples are tested using byexamples . They all use a common base setup to have some fake objects to work with: # frozen_string_literal: true require \"English\" require 'dry-types' require 'dry-struct' Warning [ :experimental ] = false if Warning . respond_to? :[] module Types include Dry . Types () end module FakeDB Rollback = Class . new ( RuntimeError ) def self . transaction yield rescue Rollback # doing rollback ... raise end end class User def initialize ( name :, age :) @name , @age = name , age end attr_reader :name , :age def save ! underage? end def errors underage? ? [ { age : \"underage\" } ] : nil end def underage? @age <= 18 end end","title":"Introduction"},{"location":"#introduction","text":"Teckel provides a common interface for wrapping your ruby business logic into, with enforced input, output and error data structures. The two main components are Operations and Chains .","title":"Introduction"},{"location":"#motivation","text":"Working with Interactor , Trailblazer's Operation and Dry-rb's Transaction and probably a hand full of inconsistent \"service objects\", I missed a system that: provides and enforces well defined input, output and error structures makes chaining multiple operation easy and reliable is easy to debug","title":"Motivation"},{"location":"#about-code-samples","text":"Code samples are tested using byexamples . They all use a common base setup to have some fake objects to work with: # frozen_string_literal: true require \"English\" require 'dry-types' require 'dry-struct' Warning [ :experimental ] = false if Warning . respond_to? :[] module Types include Dry . Types () end module FakeDB Rollback = Class . new ( RuntimeError ) def self . transaction yield rescue Rollback # doing rollback ... raise end end class User def initialize ( name :, age :) @name , @age = name , age end attr_reader :name , :age def save ! underage? end def errors underage? ? [ { age : \"underage\" } ] : nil end def underage? @age <= 18 end end","title":"About Code Samples"},{"location":"chains/around/","text":"Around hook Chains might use a around hook eg. for wrapping the entire execution in a database transaction. There hooks gets total control over the execution, so it needs to take care of calling the chain and returning it's result. require \"teckel/chain\" class CreateUser include :: Teckel :: Operation result! input Types :: Hash . schema ( name : Types :: String , age : Types :: Coercible :: Integer . optional ) output Types . Instance ( User ) error Types :: Hash . schema ( message : Types :: String , errors : Types :: Array . of ( Types :: Hash )) def call ( input ) user = User . new ( name : input [ :name ] , age : input [ :age ] ) if user . save success! ( user ) else fail ! ( message : \"Could not safe User\" , errors : user . errors ) end end end class AddFriend include :: Teckel :: Operation result! settings Struct . new ( :fail_befriend ) input Types . Instance ( User ) output Types :: Hash . schema ( user : Types . Instance ( User ), friend : Types . Instance ( User )) error Types :: Hash . schema ( message : Types :: String ) def call ( user ) if settings &. fail_befriend == :fail fail ! ( message : \"Did not find a friend.\" ) else success! ( user : user , friend : User . new ( name : \"A friend\" , age : 42 )) end end end LOG = [] class MyChain include Teckel :: Chain around -> ( chain , input ) { result = nil begin LOG << :before FakeDB . transaction do # The hook needs to call the chain: result = chain . call ( input ) raise FakeDB :: Rollback if result . failure? end LOG << :after result # ... and return the success result rescue FakeDB :: Rollback LOG << :rollback result # ... and return the failure result end } step :create , CreateUser step :befriend , AddFriend end failure_result = MyChain . with ( befriend : :fail ) . call ( name : \"Bob\" , age : 23 ) failure_result #=> #<Teckel::Chain::Result:<...>> # triggered DB rollback LOG #=> [:before, :rollback] # additional step information failure_result . step #=> :befriend # behaves just like a normal +Result+ failure_result . failure? #=> true failure_result . failure #=> {:message=>\"Did not find a friend.\"}","title":"Hooks"},{"location":"chains/around/#around-hook","text":"Chains might use a around hook eg. for wrapping the entire execution in a database transaction. There hooks gets total control over the execution, so it needs to take care of calling the chain and returning it's result. require \"teckel/chain\" class CreateUser include :: Teckel :: Operation result! input Types :: Hash . schema ( name : Types :: String , age : Types :: Coercible :: Integer . optional ) output Types . Instance ( User ) error Types :: Hash . schema ( message : Types :: String , errors : Types :: Array . of ( Types :: Hash )) def call ( input ) user = User . new ( name : input [ :name ] , age : input [ :age ] ) if user . save success! ( user ) else fail ! ( message : \"Could not safe User\" , errors : user . errors ) end end end class AddFriend include :: Teckel :: Operation result! settings Struct . new ( :fail_befriend ) input Types . Instance ( User ) output Types :: Hash . schema ( user : Types . Instance ( User ), friend : Types . Instance ( User )) error Types :: Hash . schema ( message : Types :: String ) def call ( user ) if settings &. fail_befriend == :fail fail ! ( message : \"Did not find a friend.\" ) else success! ( user : user , friend : User . new ( name : \"A friend\" , age : 42 )) end end end LOG = [] class MyChain include Teckel :: Chain around -> ( chain , input ) { result = nil begin LOG << :before FakeDB . transaction do # The hook needs to call the chain: result = chain . call ( input ) raise FakeDB :: Rollback if result . failure? end LOG << :after result # ... and return the success result rescue FakeDB :: Rollback LOG << :rollback result # ... and return the failure result end } step :create , CreateUser step :befriend , AddFriend end failure_result = MyChain . with ( befriend : :fail ) . call ( name : \"Bob\" , age : 23 ) failure_result #=> #<Teckel::Chain::Result:<...>> # triggered DB rollback LOG #=> [:before, :rollback] # additional step information failure_result . step #=> :befriend # behaves just like a normal +Result+ failure_result . failure? #=> true failure_result . failure #=> {:message=>\"Did not find a friend.\"}","title":"Around hook"},{"location":"chains/basics/","text":"Chain basics Chains run multiple Operations (\"steps\") in order, returning the success value of the last step. When any step returns a failure, the chain is stopped and that failure is returned. Operations used as steps need to return result objects (implementing Teckel::Result ). Chains always return a result object including the name of the step they origin from. This is especially useful to switch error handling for failure results. Example Defining a simple Chain with three steps. require \"teckel/chain\" class CreateUser include :: Teckel :: Operation result! input Types :: Hash . schema ( name : Types :: String , age : Types :: Coercible :: Integer . optional ) output Types . Instance ( User ) error Types :: Hash . schema ( message : Types :: String , errors : Types :: Array . of ( Types :: Hash )) def call ( input ) user = User . new ( name : input [ :name ] , age : input [ :age ] ) if user . save success! ( user ) else fail ! ( message : \"Could not save User\" , errors : user . errors ) end end end class LogUser include :: Teckel :: Operation result! input Types . Instance ( User ) error none output input def call ( usr ) Logger . new ( File :: NULL ) . info ( \"User #{ usr . name } created\" ) success! ( usr ) # we need to return the correct output type end end class AddFriend include :: Teckel :: Operation result! settings Struct . new ( :fail_befriend ) input Types . Instance ( User ) output Types :: Hash . schema ( user : Types . Instance ( User ), friend : Types . Instance ( User )) error Types :: Hash . schema ( message : Types :: String ) def call ( user ) if settings &. fail_befriend == :fail fail ! ( message : \"Did not find a friend.\" ) else success! ( user : user , friend : User . new ( name : \"A friend\" , age : 42 )) end end end class MyChain include Teckel :: Chain step :create , CreateUser step :log , LogUser step :befriend , AddFriend finalize! end result = MyChain . call ( name : \"Bob\" , age : 23 ) result #=> #<Teckel::Chain::Result:<...>> result . success [ :user ] #=> #<User:<...> @name=\"Bob\", @age=23> result . success [ :friend ] #=> #<User:<...> @name=\"A friend\", @age=42> failure_result = MyChain . with ( befriend : :fail ) . call ( name : \"Bob\" , age : 23 ) failure_result #=> #<Teckel::Chain::Result:<...>> # additional step information failure_result . step #=> :befriend # behaves just like a normal +Result+ failure_result . failure? #=> true failure_result . failure #=> {:message=>\"Did not find a friend.\"} Pattern matching Hash style: result = case MyChain . call ( name : \"Bob\" , age : 23 ) in { success : false , step : :befriend , value : value } [ \"Failed\" , value ] in { success : true , value : value } [ \"Success result\" , value ] end result #=> [\"Success result\", {:user=>#<User:<...> @name=\"Bob\", @age=23>, :friend=>#<User:<...> @name=\"A friend\", @age=42>}] Array style: result = case MyChain . with ( befriend : :fail ) . call ( name : \"Bob\" , age : 23 ) in [ false , :befriend , value ] [ \"Failed\" , value ] in [ true , value ] [ \"Success result\" , value ] end result #=> [\"Failed\", {:message=>\"Did not find a friend.\"}]","title":"Basics"},{"location":"chains/basics/#chain-basics","text":"Chains run multiple Operations (\"steps\") in order, returning the success value of the last step. When any step returns a failure, the chain is stopped and that failure is returned. Operations used as steps need to return result objects (implementing Teckel::Result ). Chains always return a result object including the name of the step they origin from. This is especially useful to switch error handling for failure results.","title":"Chain basics"},{"location":"chains/basics/#example","text":"Defining a simple Chain with three steps. require \"teckel/chain\" class CreateUser include :: Teckel :: Operation result! input Types :: Hash . schema ( name : Types :: String , age : Types :: Coercible :: Integer . optional ) output Types . Instance ( User ) error Types :: Hash . schema ( message : Types :: String , errors : Types :: Array . of ( Types :: Hash )) def call ( input ) user = User . new ( name : input [ :name ] , age : input [ :age ] ) if user . save success! ( user ) else fail ! ( message : \"Could not save User\" , errors : user . errors ) end end end class LogUser include :: Teckel :: Operation result! input Types . Instance ( User ) error none output input def call ( usr ) Logger . new ( File :: NULL ) . info ( \"User #{ usr . name } created\" ) success! ( usr ) # we need to return the correct output type end end class AddFriend include :: Teckel :: Operation result! settings Struct . new ( :fail_befriend ) input Types . Instance ( User ) output Types :: Hash . schema ( user : Types . Instance ( User ), friend : Types . Instance ( User )) error Types :: Hash . schema ( message : Types :: String ) def call ( user ) if settings &. fail_befriend == :fail fail ! ( message : \"Did not find a friend.\" ) else success! ( user : user , friend : User . new ( name : \"A friend\" , age : 42 )) end end end class MyChain include Teckel :: Chain step :create , CreateUser step :log , LogUser step :befriend , AddFriend finalize! end result = MyChain . call ( name : \"Bob\" , age : 23 ) result #=> #<Teckel::Chain::Result:<...>> result . success [ :user ] #=> #<User:<...> @name=\"Bob\", @age=23> result . success [ :friend ] #=> #<User:<...> @name=\"A friend\", @age=42> failure_result = MyChain . with ( befriend : :fail ) . call ( name : \"Bob\" , age : 23 ) failure_result #=> #<Teckel::Chain::Result:<...>> # additional step information failure_result . step #=> :befriend # behaves just like a normal +Result+ failure_result . failure? #=> true failure_result . failure #=> {:message=>\"Did not find a friend.\"}","title":"Example"},{"location":"chains/basics/#pattern-matching","text":"Hash style: result = case MyChain . call ( name : \"Bob\" , age : 23 ) in { success : false , step : :befriend , value : value } [ \"Failed\" , value ] in { success : true , value : value } [ \"Success result\" , value ] end result #=> [\"Success result\", {:user=>#<User:<...> @name=\"Bob\", @age=23>, :friend=>#<User:<...> @name=\"A friend\", @age=42>}] Array style: result = case MyChain . with ( befriend : :fail ) . call ( name : \"Bob\" , age : 23 ) in [ false , :befriend , value ] [ \"Failed\" , value ] in [ true , value ] [ \"Success result\" , value ] end result #=> [\"Failed\", {:message=>\"Did not find a friend.\"}]","title":"Pattern matching"},{"location":"operations/basics/","text":"Operation basics Using in-line constants as contracts class CreateUserInline include Teckel :: Operation class Input def initialize ( name :, age :) @name , @age = name , age end attr_reader :name , :age end input_constructor -> ( data ) { input . new ( ** data ) } Output = :: User class Error def initialize ( message , errors ) @message , @errors = message , errors end attr_reader :message , :errors end error_constructor :new def call ( input ) user = :: User . new ( name : input . name , age : input . age ) if user . save success! ( user ) else fail ! ( \"Could not save User\" , user . errors ) end end end A Successful call: CreateUserInline . call ( name : \"Bob\" , age : 23 ) #=> #<User:<...> @name=\"Bob\", @age=23> A failure call: CreateUserInline . call ( name : \"Bob\" , age : 10 ) #=> #<CreateUserInline::Error:<...> @message=\"Could not save User\", @errors=[{:age=>\"underage\"}]> Calling with unsuspected input: CreateUserInline . call ( unwanted : \"input\" ) rescue $ERROR_INFO #=> #<ArgumentError: missing keywords: :name, :age> CreateUserInline . call ( unwanted : \"input\" , name : \"a\" , age : 10 ) rescue $ERROR_INFO #=> #<ArgumentError: unknown keyword: :unwanted> Using Dry::Types as contracts Here is a simple Operation using Dry::Types for it's input, output and error contracts: class CreateUserDry include Teckel :: Operation input Types :: Hash . schema ( name : Types :: String , age : Types :: Coercible :: Integer ) output Types . Instance ( User ) error Types :: Hash . schema ( message : Types :: String , errors : Types :: Array . of ( Types :: Hash )) def call ( input ) user = User . new ( name : input [ :name ] , age : input [ :age ] ) if user . save success! ( user ) else fail ! ( message : \"Could not save User\" , errors : user . errors ) end end end A Successful call: CreateUserDry . call ( name : \"Bob\" , age : 23 ) #=> #<User:<...> @name=\"Bob\", @age=23> A failure call: CreateUserDry . call ( name : \"Bob\" , age : 10 ) #=> {:message=>\"Could not save User\", :errors=>[{:age=>\"underage\"}]} Build your contracts in a way that let you know: CreateUserDry . call ( unwanted : \"input\" ) rescue $ERROR_INFO #=> #<Dry::Types::MissingKeyError: :name is missing in Hash input> If your contracts support Feed an instance of the input class directly to call: CreateUserDry . call ( CreateUserDry . input [ name : \"Bob\" , age : 23 ] ) #=> #<User:<...> @name=\"Bob\", @age=23> Expecting none class NoOp include Teckel :: Operation input none output none error none # injecting values to fake behavior settings Struct . new ( :out , :err , :ret , keyword_init : true ) def call ( _input ) # you'll still need to take that argument if settings fail ! ( nil ) if settings . err == :nil success! ( nil ) if settings . out == :nil fail ! if settings . err == :nothing success! if settings . out == :nothing fail ! ( settings . err ) if settings . err success! ( settings . out ) if settings . out settings . ret # any normal return value will be ignored end end end Expects to be called with nothing or nil , calling with any value will raise an error: NoOp . call #=> nil NoOp . call ( nil ) #=> nil NoOp . call ( \"test\" ) rescue $ERROR_INFO #=> #<ArgumentError: None called with arguments> Expects no success value: NoOp . call #=> nil NoOp . with ( out : nil ) . call #=> nil NoOp . with ( out : :nil ) . call #=> nil NoOp . with ( out : :nothing ) . call #=> nil NoOp . with ( out : \"test\" ) . call rescue $ERROR_INFO #=> #<ArgumentError: None called with arguments> NoOp . with ( ret : \"test\" ) . call # return values will be ignored #=> nil Expects no failure value: NoOp . with ( err : nil ) . call #=> nil NoOp . with ( err : :nil ) . call #=> nil NoOp . with ( err : :nothing ) . call #=> nil NoOp . with ( err : \"test\" ) . call rescue $ERROR_INFO #=> #<ArgumentError: None called with arguments> Pattern matching class CreateUser include :: Teckel :: Operation result! input Types :: Hash . schema ( name : Types :: String , age : Types :: Coercible :: Integer . optional ) output Types . Instance ( User ) error Types :: Hash . schema ( message : Types :: String , errors : Types :: Array . of ( Types :: Hash )) def call ( input ) user = User . new ( name : input [ :name ] , age : input [ :age ] ) if user . save success! ( user ) else fail ! ( message : \"Could not save User\" , errors : user . errors ) end end end Hash style: result = case CreateUser . call ( name : \"Bob\" , age : 23 ) in { success : false , value : value } [ \"Failed\" , value ] in { success : true , value : value } [ \"Success result\" , value ] end result #=> [\"Success result\", #<User:<...> @name=\"Bob\", @age=23>] Array style: result = case CreateUser . call ( name : \"Bob\" , age : 10 ) in [ false , value ] [ \"Failed\" , value ] in [ true , value ] [ \"Success result\" , value ] end result #=> [\"Failed\", {:message=>\"Could not save User\", :errors=>[{:age=>\"underage\"}]}]","title":"Basics"},{"location":"operations/basics/#operation-basics","text":"","title":"Operation basics"},{"location":"operations/basics/#using-in-line-constants-as-contracts","text":"class CreateUserInline include Teckel :: Operation class Input def initialize ( name :, age :) @name , @age = name , age end attr_reader :name , :age end input_constructor -> ( data ) { input . new ( ** data ) } Output = :: User class Error def initialize ( message , errors ) @message , @errors = message , errors end attr_reader :message , :errors end error_constructor :new def call ( input ) user = :: User . new ( name : input . name , age : input . age ) if user . save success! ( user ) else fail ! ( \"Could not save User\" , user . errors ) end end end A Successful call: CreateUserInline . call ( name : \"Bob\" , age : 23 ) #=> #<User:<...> @name=\"Bob\", @age=23> A failure call: CreateUserInline . call ( name : \"Bob\" , age : 10 ) #=> #<CreateUserInline::Error:<...> @message=\"Could not save User\", @errors=[{:age=>\"underage\"}]> Calling with unsuspected input: CreateUserInline . call ( unwanted : \"input\" ) rescue $ERROR_INFO #=> #<ArgumentError: missing keywords: :name, :age> CreateUserInline . call ( unwanted : \"input\" , name : \"a\" , age : 10 ) rescue $ERROR_INFO #=> #<ArgumentError: unknown keyword: :unwanted>","title":"Using in-line constants as contracts"},{"location":"operations/basics/#using-drytypes-as-contracts","text":"Here is a simple Operation using Dry::Types for it's input, output and error contracts: class CreateUserDry include Teckel :: Operation input Types :: Hash . schema ( name : Types :: String , age : Types :: Coercible :: Integer ) output Types . Instance ( User ) error Types :: Hash . schema ( message : Types :: String , errors : Types :: Array . of ( Types :: Hash )) def call ( input ) user = User . new ( name : input [ :name ] , age : input [ :age ] ) if user . save success! ( user ) else fail ! ( message : \"Could not save User\" , errors : user . errors ) end end end A Successful call: CreateUserDry . call ( name : \"Bob\" , age : 23 ) #=> #<User:<...> @name=\"Bob\", @age=23> A failure call: CreateUserDry . call ( name : \"Bob\" , age : 10 ) #=> {:message=>\"Could not save User\", :errors=>[{:age=>\"underage\"}]} Build your contracts in a way that let you know: CreateUserDry . call ( unwanted : \"input\" ) rescue $ERROR_INFO #=> #<Dry::Types::MissingKeyError: :name is missing in Hash input> If your contracts support Feed an instance of the input class directly to call: CreateUserDry . call ( CreateUserDry . input [ name : \"Bob\" , age : 23 ] ) #=> #<User:<...> @name=\"Bob\", @age=23>","title":"Using Dry::Types as contracts"},{"location":"operations/basics/#expecting-none","text":"class NoOp include Teckel :: Operation input none output none error none # injecting values to fake behavior settings Struct . new ( :out , :err , :ret , keyword_init : true ) def call ( _input ) # you'll still need to take that argument if settings fail ! ( nil ) if settings . err == :nil success! ( nil ) if settings . out == :nil fail ! if settings . err == :nothing success! if settings . out == :nothing fail ! ( settings . err ) if settings . err success! ( settings . out ) if settings . out settings . ret # any normal return value will be ignored end end end Expects to be called with nothing or nil , calling with any value will raise an error: NoOp . call #=> nil NoOp . call ( nil ) #=> nil NoOp . call ( \"test\" ) rescue $ERROR_INFO #=> #<ArgumentError: None called with arguments> Expects no success value: NoOp . call #=> nil NoOp . with ( out : nil ) . call #=> nil NoOp . with ( out : :nil ) . call #=> nil NoOp . with ( out : :nothing ) . call #=> nil NoOp . with ( out : \"test\" ) . call rescue $ERROR_INFO #=> #<ArgumentError: None called with arguments> NoOp . with ( ret : \"test\" ) . call # return values will be ignored #=> nil Expects no failure value: NoOp . with ( err : nil ) . call #=> nil NoOp . with ( err : :nil ) . call #=> nil NoOp . with ( err : :nothing ) . call #=> nil NoOp . with ( err : \"test\" ) . call rescue $ERROR_INFO #=> #<ArgumentError: None called with arguments>","title":"Expecting none"},{"location":"operations/basics/#pattern-matching","text":"class CreateUser include :: Teckel :: Operation result! input Types :: Hash . schema ( name : Types :: String , age : Types :: Coercible :: Integer . optional ) output Types . Instance ( User ) error Types :: Hash . schema ( message : Types :: String , errors : Types :: Array . of ( Types :: Hash )) def call ( input ) user = User . new ( name : input [ :name ] , age : input [ :age ] ) if user . save success! ( user ) else fail ! ( message : \"Could not save User\" , errors : user . errors ) end end end Hash style: result = case CreateUser . call ( name : \"Bob\" , age : 23 ) in { success : false , value : value } [ \"Failed\" , value ] in { success : true , value : value } [ \"Success result\" , value ] end result #=> [\"Success result\", #<User:<...> @name=\"Bob\", @age=23>] Array style: result = case CreateUser . call ( name : \"Bob\" , age : 10 ) in [ false , value ] [ \"Failed\" , value ] in [ true , value ] [ \"Success result\" , value ] end result #=> [\"Failed\", {:message=>\"Could not save User\", :errors=>[{:age=>\"underage\"}]}]","title":"Pattern matching"},{"location":"operations/dependency_injection/","text":"Inject settings Your call method should only get data to work on. Use settings for \"how\" or \"with what\" to do it. Settings (just as input, output and error) are defined using a contract class and made available via the #settings instance method only when set. class MyOperation include :: Teckel :: Operation settings Struct . new ( :logger ) input none output none error none def call ( _input ) puts \"no settings\" if settings . nil? settings . logger . puts \"called\" if settings &. logger end end With no settings: MyOperation . call ( nil ) no settings #=> nil With Logger require 'stringio' my_logger = StringIO . new MyOperation . with ( my_logger ) . call () my_logger . string #=> \"called\\n\" As constant class OtherOperation include Teckel :: Operation class Settings def initialize ( foo :, bar :) @foo , @bar = foo , bar end attr_reader :foo , :bar end # MyOperation.with(\"foo\", \"bar\") # -> Settings.new(\"foo\", \"bar\") settings_constructor :new end Default Settings Initialize Setting by default. This avoids nil settings, but forces you to either make your Settings class accept no arguments for initialization, or provide acceptable defaults. Note that, default settings will not get merged with call time setting. Default settings will be ignored when calling like this: MyOperation.with(call_time_settings).call . class BaseOperation include Teckel :: Operation class Settings def initialize ( * values ) @values = values end attr_reader :values end settings_constructor :new input none output Types :: Array error none def call ( _ ) success! ( settings . values ) end end Empty defaults class EmptyDefaults < BaseOperation default_settings! # Settings.new end With no settings: EmptyDefaults . call #=> [] With injected settings: EmptyDefaults . with ( :injected ) . call #=> [:injected] Static defaults class StaticDefaults < BaseOperation default_settings! ( :foo , :bar ) # Settings.new(:foo, :bar) end With no settings: StaticDefaults . call #=> [:foo, :bar] With injected settings: StaticDefaults . with ( :injected ) . call #=> [:injected] Call time defaults class CallTimeDefaults < BaseOperation default_settings! -> { settings_constructor . call ( Time . now ) } # Settings.new(Time.now) end With no settings: a = CallTimeDefaults . call . first b = CallTimeDefaults . call . first a . class #=> Time b . class #=> Time a < b #=> true With injected settings: CallTimeDefaults . with ( :injected ) . call #=> [:injected]","title":"Inject settings"},{"location":"operations/dependency_injection/#inject-settings","text":"Your call method should only get data to work on. Use settings for \"how\" or \"with what\" to do it. Settings (just as input, output and error) are defined using a contract class and made available via the #settings instance method only when set. class MyOperation include :: Teckel :: Operation settings Struct . new ( :logger ) input none output none error none def call ( _input ) puts \"no settings\" if settings . nil? settings . logger . puts \"called\" if settings &. logger end end With no settings: MyOperation . call ( nil ) no settings #=> nil With Logger require 'stringio' my_logger = StringIO . new MyOperation . with ( my_logger ) . call () my_logger . string #=> \"called\\n\"","title":"Inject settings"},{"location":"operations/dependency_injection/#as-constant","text":"class OtherOperation include Teckel :: Operation class Settings def initialize ( foo :, bar :) @foo , @bar = foo , bar end attr_reader :foo , :bar end # MyOperation.with(\"foo\", \"bar\") # -> Settings.new(\"foo\", \"bar\") settings_constructor :new end","title":"As constant"},{"location":"operations/dependency_injection/#default-settings","text":"Initialize Setting by default. This avoids nil settings, but forces you to either make your Settings class accept no arguments for initialization, or provide acceptable defaults. Note that, default settings will not get merged with call time setting. Default settings will be ignored when calling like this: MyOperation.with(call_time_settings).call . class BaseOperation include Teckel :: Operation class Settings def initialize ( * values ) @values = values end attr_reader :values end settings_constructor :new input none output Types :: Array error none def call ( _ ) success! ( settings . values ) end end","title":"Default Settings"},{"location":"operations/dependency_injection/#empty-defaults","text":"class EmptyDefaults < BaseOperation default_settings! # Settings.new end With no settings: EmptyDefaults . call #=> [] With injected settings: EmptyDefaults . with ( :injected ) . call #=> [:injected]","title":"Empty defaults"},{"location":"operations/dependency_injection/#static-defaults","text":"class StaticDefaults < BaseOperation default_settings! ( :foo , :bar ) # Settings.new(:foo, :bar) end With no settings: StaticDefaults . call #=> [:foo, :bar] With injected settings: StaticDefaults . with ( :injected ) . call #=> [:injected]","title":"Static defaults"},{"location":"operations/dependency_injection/#call-time-defaults","text":"class CallTimeDefaults < BaseOperation default_settings! -> { settings_constructor . call ( Time . now ) } # Settings.new(Time.now) end With no settings: a = CallTimeDefaults . call . first b = CallTimeDefaults . call . first a . class #=> Time b . class #=> Time a < b #=> true With injected settings: CallTimeDefaults . with ( :injected ) . call #=> [:injected]","title":"Call time defaults"},{"location":"operations/result_objects/","text":"Result objects Build-in class CreateUser include Teckel :: Operation # Shortcut for # result Teckel::Operation::Result result! input Types :: Hash . schema ( name : Types :: String , age : Types :: Coercible :: Integer ) output Types . Instance ( User ) error Types :: Hash . schema ( message : Types :: String , errors : Types :: Array . of ( Types :: Hash )) def call ( input ) user = User . new ( name : input [ :name ] , age : input [ :age ] ) if user . save success! ( user ) else fail ! ( message : \"Could not save User\" , errors : user . errors ) end end end A success call: result = CreateUser . call ( name : \"Bob\" , age : 23 ) result #=> #<Teckel::Operation::Result:<...>> result . successful? #=> true result . failure? #=> false result . success #=> #<User:<...> @name=\"Bob\", @age=23> A failure call: result = CreateUser . call ( name : \"Bob\" , age : 10 ) result #=> #<Teckel::Operation::Result:<...>> result . successful? #=> false result . failure? #=> true result . failure #=> {:message=>\"Could not save User\", :errors=>[{:age=>\"underage\"}]} result . success do | value | # do something with the error value puts value [ :message ] # return something useful value [ :errors ] end Could not save User #=> [{:age=>\"underage\"}] Custom You can use your own result object. If you plan using your operation in a Chain , the should implement the interface defined in Teckel::Result . require 'time' class MyResult include Teckel :: Result def initialize ( value , success , opts = {}) @value , @success , @opts = value , ( !! success ) . freeze , opts end # implementing Teckel::Result attr_reader :value # implementing Teckel::Result def successful? @success end def at @opts [ :at ] end end class CreateUserOtherResult include Teckel :: Operation result MyResult result_constructor -> ( value , success ) { MyResult . new ( value , success , at : Time . now ) } input Types :: Hash . schema ( name : Types :: String , age : Types :: Coercible :: Integer ) output Types . Instance ( User ) error Types :: Hash . schema ( message : Types :: String , errors : Types :: Array . of ( Types :: Hash )) def call ( input ) user = User . new ( name : input [ :name ] , age : input [ :age ] ) if user . save success! ( user ) else fail ! ( message : \"Could not save User\" , errors : user . errors ) end end finalize! end result = CreateUserOtherResult . call ( name : \"Bob\" , age : 23 ) result #=> #<MyResult:<...> @value=#<User:<...>>, @success=true, @opts={:at=><time>}> result . at #=> <time> result . successful? #=> true result . failure? #=> false result . value #=> #<User:<...> @name=\"Bob\", @age=23> Dry-Monads require 'dry/monads' # we need some glue code to make them work with Chains class DryResult include Teckel :: Result include Dry :: Monads [ :result ] def initialize ( value , success ) @value , @success = value , ( !! success ) . freeze end # implementing Teckel::Result attr_reader :value # implementing Teckel::Result def successful? @success end def to_monad @success ? Success ( value ) : Failure ( value ) end end class CreateUserDry include Teckel :: Operation result DryResult result_constructor :new input Types :: Hash . schema ( name : Types :: String , age : Types :: Coercible :: Integer ) output Types . Instance ( User ) error Types :: Hash . schema ( message : Types :: String , errors : Types :: Array . of ( Types :: Hash )) def call ( input ) user = User . new ( name : input [ :name ] , age : input [ :age ] ) if user . save success! ( user ) else fail ! ( message : \"Could not save User\" , errors : user . errors ) end end finalize! end result = CreateUserDry . call ( name : \"Bob\" , age : 23 ) result . to_monad #=> Success(#<User:<...> @name=\"Bob\", @age=23>)","title":"Result objects"},{"location":"operations/result_objects/#result-objects","text":"","title":"Result objects"},{"location":"operations/result_objects/#build-in","text":"class CreateUser include Teckel :: Operation # Shortcut for # result Teckel::Operation::Result result! input Types :: Hash . schema ( name : Types :: String , age : Types :: Coercible :: Integer ) output Types . Instance ( User ) error Types :: Hash . schema ( message : Types :: String , errors : Types :: Array . of ( Types :: Hash )) def call ( input ) user = User . new ( name : input [ :name ] , age : input [ :age ] ) if user . save success! ( user ) else fail ! ( message : \"Could not save User\" , errors : user . errors ) end end end A success call: result = CreateUser . call ( name : \"Bob\" , age : 23 ) result #=> #<Teckel::Operation::Result:<...>> result . successful? #=> true result . failure? #=> false result . success #=> #<User:<...> @name=\"Bob\", @age=23> A failure call: result = CreateUser . call ( name : \"Bob\" , age : 10 ) result #=> #<Teckel::Operation::Result:<...>> result . successful? #=> false result . failure? #=> true result . failure #=> {:message=>\"Could not save User\", :errors=>[{:age=>\"underage\"}]} result . success do | value | # do something with the error value puts value [ :message ] # return something useful value [ :errors ] end Could not save User #=> [{:age=>\"underage\"}]","title":"Build-in"},{"location":"operations/result_objects/#custom","text":"You can use your own result object. If you plan using your operation in a Chain , the should implement the interface defined in Teckel::Result . require 'time' class MyResult include Teckel :: Result def initialize ( value , success , opts = {}) @value , @success , @opts = value , ( !! success ) . freeze , opts end # implementing Teckel::Result attr_reader :value # implementing Teckel::Result def successful? @success end def at @opts [ :at ] end end class CreateUserOtherResult include Teckel :: Operation result MyResult result_constructor -> ( value , success ) { MyResult . new ( value , success , at : Time . now ) } input Types :: Hash . schema ( name : Types :: String , age : Types :: Coercible :: Integer ) output Types . Instance ( User ) error Types :: Hash . schema ( message : Types :: String , errors : Types :: Array . of ( Types :: Hash )) def call ( input ) user = User . new ( name : input [ :name ] , age : input [ :age ] ) if user . save success! ( user ) else fail ! ( message : \"Could not save User\" , errors : user . errors ) end end finalize! end result = CreateUserOtherResult . call ( name : \"Bob\" , age : 23 ) result #=> #<MyResult:<...> @value=#<User:<...>>, @success=true, @opts={:at=><time>}> result . at #=> <time> result . successful? #=> true result . failure? #=> false result . value #=> #<User:<...> @name=\"Bob\", @age=23>","title":"Custom"},{"location":"operations/result_objects/#dry-monads","text":"require 'dry/monads' # we need some glue code to make them work with Chains class DryResult include Teckel :: Result include Dry :: Monads [ :result ] def initialize ( value , success ) @value , @success = value , ( !! success ) . freeze end # implementing Teckel::Result attr_reader :value # implementing Teckel::Result def successful? @success end def to_monad @success ? Success ( value ) : Failure ( value ) end end class CreateUserDry include Teckel :: Operation result DryResult result_constructor :new input Types :: Hash . schema ( name : Types :: String , age : Types :: Coercible :: Integer ) output Types . Instance ( User ) error Types :: Hash . schema ( message : Types :: String , errors : Types :: Array . of ( Types :: Hash )) def call ( input ) user = User . new ( name : input [ :name ] , age : input [ :age ] ) if user . save success! ( user ) else fail ! ( message : \"Could not save User\" , errors : user . errors ) end end finalize! end result = CreateUserDry . call ( name : \"Bob\" , age : 23 ) result . to_monad #=> Success(#<User:<...> @name=\"Bob\", @age=23>)","title":"Dry-Monads"}]}